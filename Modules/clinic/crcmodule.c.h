/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_long.h"          // _PyLong_UnsignedLongLong_Converter()
#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_crc_crcu64_combine__doc__,
"combine($self, crc1, crc2, len2, /)\n"
"--\n"
"\n"
"Return the combined CRC of the two parts.\n"
"\n"
"  crc1\n"
"    CRC result of the first part.\n"
"  crc2\n"
"    CRC result of the second part.\n"
"  len2\n"
"    Length of the second part, in bytes.\n"
"\n"
"The CRC of the two parts must be generated by the same configuration of this\n"
"CRC object.\n"
"This method leaves the internal state of the CRC object unchanged.");

#define _CRC_CRCU64_COMBINE_METHODDEF    \
    {"combine", _PyCFunction_CAST(_crc_crcu64_combine), METH_FASTCALL, _crc_crcu64_combine__doc__},

static PyObject *
_crc_crcu64_combine_impl(crcu64object *self, unsigned long long crc1,
                         unsigned long long crc2, size_t len2);

static PyObject *
_crc_crcu64_combine(crcu64object *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    unsigned long long crc1;
    unsigned long long crc2;
    size_t len2;

    if (!_PyArg_CheckPositional("combine", nargs, 3, 3)) {
        goto exit;
    }
    if (!_PyLong_UnsignedLongLong_Converter(args[0], &crc1)) {
        goto exit;
    }
    if (!_PyLong_UnsignedLongLong_Converter(args[1], &crc2)) {
        goto exit;
    }
    if (!_PyLong_Size_t_Converter(args[2], &len2)) {
        goto exit;
    }
    return_value = _crc_crcu64_combine_impl(self, crc1, crc2, len2);

exit:
    return return_value;
}

PyDoc_STRVAR(_crc_crcu64_copy__doc__,
"copy($self, /)\n"
"--\n"
"\n"
"Return a copy of the CRC object.");

#define _CRC_CRCU64_COPY_METHODDEF    \
    {"copy", _PyCFunction_CAST(_crc_crcu64_copy), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, _crc_crcu64_copy__doc__},

static PyObject *
_crc_crcu64_copy_impl(crcu64object *self, PyTypeObject *cls);

static PyObject *
_crc_crcu64_copy(crcu64object *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "copy() takes no arguments");
        return NULL;
    }
    return _crc_crcu64_copy_impl(self, cls);
}

PyDoc_STRVAR(_crc_crcu64_digest__doc__,
"digest($self, /)\n"
"--\n"
"\n"
"Return the digest value as a bytes object.");

#define _CRC_CRCU64_DIGEST_METHODDEF    \
    {"digest", (PyCFunction)_crc_crcu64_digest, METH_NOARGS, _crc_crcu64_digest__doc__},

static PyObject *
_crc_crcu64_digest_impl(crcu64object *self);

static PyObject *
_crc_crcu64_digest(crcu64object *self, PyObject *Py_UNUSED(ignored))
{
    return _crc_crcu64_digest_impl(self);
}

PyDoc_STRVAR(_crc_crcu64_hexdigest__doc__,
"hexdigest($self, /)\n"
"--\n"
"\n"
"Return the digest value as a string of hexadecimal digits.");

#define _CRC_CRCU64_HEXDIGEST_METHODDEF    \
    {"hexdigest", (PyCFunction)_crc_crcu64_hexdigest, METH_NOARGS, _crc_crcu64_hexdigest__doc__},

static PyObject *
_crc_crcu64_hexdigest_impl(crcu64object *self);

static PyObject *
_crc_crcu64_hexdigest(crcu64object *self, PyObject *Py_UNUSED(ignored))
{
    return _crc_crcu64_hexdigest_impl(self);
}

PyDoc_STRVAR(_crc_crcu64_clear__doc__,
"clear($self, init=None, /)\n"
"--\n"
"\n"
"Reset internal computations.\n"
"\n"
"  init\n"
"    Initial CRC value.\n"
"\n"
"Computations resume from the provided initial value, or the default if not\n"
"provided instead.");

#define _CRC_CRCU64_CLEAR_METHODDEF    \
    {"clear", _PyCFunction_CAST(_crc_crcu64_clear), METH_FASTCALL, _crc_crcu64_clear__doc__},

static PyObject *
_crc_crcu64_clear_impl(crcu64object *self, PyObject *init);

static PyObject *
_crc_crcu64_clear(crcu64object *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *init = NULL;

    if (!_PyArg_CheckPositional("clear", nargs, 0, 1)) {
        goto exit;
    }
    if (nargs < 1) {
        goto skip_optional;
    }
    init = args[0];
skip_optional:
    return_value = _crc_crcu64_clear_impl(self, init);

exit:
    return return_value;
}

PyDoc_STRVAR(_crc_crcu64_update__doc__,
"update($self, data, /)\n"
"--\n"
"\n"
"Update this object\'s state with the provided string.\n"
"\n"
"For each input byte, any bits above the configured CRC bit width are ignored.");

#define _CRC_CRCU64_UPDATE_METHODDEF    \
    {"update", (PyCFunction)_crc_crcu64_update, METH_O, _crc_crcu64_update__doc__},

static PyObject *
_crc_crcu64_update_impl(crcu64object *self, Py_buffer *data);

static PyObject *
_crc_crcu64_update(crcu64object *self, PyObject *arg)
{
    PyObject *return_value = NULL;
    Py_buffer data = {NULL, NULL};

    if (PyObject_GetBuffer(arg, &data, PyBUF_SIMPLE) != 0) {
        goto exit;
    }
    return_value = _crc_crcu64_update_impl(self, &data);

exit:
    /* Cleanup for data */
    if (data.obj) {
       PyBuffer_Release(&data);
    }

    return return_value;
}

PyDoc_STRVAR(_crc_crcu64_update_word__doc__,
"update_word($self, word, width, /)\n"
"--\n"
"\n"
"Update this object\'s state with the provided word.\n"
"\n"
"  word\n"
"    Integer data word to feed to the CRC algorithm.\n"
"    Any bits above width are ignored.\n"
"  width\n"
"    Number of data word bits to process, up to the configured CRC width.");

#define _CRC_CRCU64_UPDATE_WORD_METHODDEF    \
    {"update_word", _PyCFunction_CAST(_crc_crcu64_update_word), METH_FASTCALL, _crc_crcu64_update_word__doc__},

static PyObject *
_crc_crcu64_update_word_impl(crcu64object *self, unsigned long long word,
                             int width);

static PyObject *
_crc_crcu64_update_word(crcu64object *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    unsigned long long word;
    int width;

    if (!_PyArg_CheckPositional("update_word", nargs, 2, 2)) {
        goto exit;
    }
    if (!_PyLong_UnsignedLongLong_Converter(args[0], &word)) {
        goto exit;
    }
    width = PyLong_AsInt(args[1]);
    if (width == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = _crc_crcu64_update_word_impl(self, word, width);

exit:
    return return_value;
}

PyDoc_STRVAR(_crc_crcu64_zero_bits__doc__,
"zero_bits($self, numbits, /)\n"
"--\n"
"\n"
"Update this object\'s state with a number of zero (NULL) bits.\n"
"\n"
"  numbits\n"
"    Number of input bits.");

#define _CRC_CRCU64_ZERO_BITS_METHODDEF    \
    {"zero_bits", (PyCFunction)_crc_crcu64_zero_bits, METH_O, _crc_crcu64_zero_bits__doc__},

static PyObject *
_crc_crcu64_zero_bits_impl(crcu64object *self, size_t numbits);

static PyObject *
_crc_crcu64_zero_bits(crcu64object *self, PyObject *arg)
{
    PyObject *return_value = NULL;
    size_t numbits;

    if (!_PyLong_Size_t_Converter(arg, &numbits)) {
        goto exit;
    }
    return_value = _crc_crcu64_zero_bits_impl(self, numbits);

exit:
    return return_value;
}

PyDoc_STRVAR(_crc_crcu64_zero_bytes__doc__,
"zero_bytes($self, numbytes, /)\n"
"--\n"
"\n"
"Update this object\'s state with a number of zero (NULL) bytes.\n"
"\n"
"  numbytes\n"
"    Number of input bytes.");

#define _CRC_CRCU64_ZERO_BYTES_METHODDEF    \
    {"zero_bytes", (PyCFunction)_crc_crcu64_zero_bytes, METH_O, _crc_crcu64_zero_bytes__doc__},

static PyObject *
_crc_crcu64_zero_bytes_impl(crcu64object *self, size_t numbytes);

static PyObject *
_crc_crcu64_zero_bytes(crcu64object *self, PyObject *arg)
{
    PyObject *return_value = NULL;
    size_t numbytes;

    if (!_PyLong_Size_t_Converter(arg, &numbytes)) {
        goto exit;
    }
    return_value = _crc_crcu64_zero_bytes_impl(self, numbytes);

exit:
    return return_value;
}

PyDoc_STRVAR(_crc_crc__doc__,
"crc($module, /, data=None, *, name=None, width=None, poly=None,\n"
"    init=None, refin=None, refout=None, xorout=None, method=\'wordwise\',\n"
"    usedforsecurity=False)\n"
"--\n"
"\n"
"Return a new CRC object; optionally initialized with a byte string.\n"
"\n"
"  data\n"
"    Byte string to update after initialization.\n"
"  name\n"
"    Template configuration name.\n"
"    If no other options are provided, default to \"crc-32\".\n"
"  width\n"
"    CRC bit width, between 1 and MAX_WIDTH.\n"
"    Mandatory if no name is provided.\n"
"  poly\n"
"    CRC polynomial, between 1 and the maximum for the configured width.\n"
"    Mandatory if no name is provided.\n"
"  init\n"
"    CRC initial value, compatible with the configured width.\n"
"  refin\n"
"    Reversing input bits, across most and least significant bits; bool.\n"
"  refout\n"
"    Reversing output bits, across most and least significant bits; bool.\n"
"  xorout\n"
"    Output result inversion bit mask. Applied after output bit reversal.\n"
"  method\n"
"    Algorithm method, one of: \"bitwise\", \"bytewise\", \"wordwise\".\n"
"  usedforsecurity\n"
"    Ignored. Please leave it false, because a CRC is not secure.");

#define _CRC_CRC_METHODDEF    \
    {"crc", _PyCFunction_CAST(_crc_crc), METH_FASTCALL|METH_KEYWORDS, _crc_crc__doc__},

static PyObject *
_crc_crc_impl(PyObject *module, Py_buffer *data, PyObject *name,
              PyObject *width, PyObject *poly, PyObject *init,
              PyObject *refin, PyObject *refout, PyObject *xorout,
              PyObject *method, int usedforsecurity);

static PyObject *
_crc_crc(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 10
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(data), &_Py_ID(name), &_Py_ID(width), &_Py_ID(poly), &_Py_ID(init), &_Py_ID(refin), &_Py_ID(refout), &_Py_ID(xorout), &_Py_ID(method), &_Py_ID(usedforsecurity), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"data", "name", "width", "poly", "init", "refin", "refout", "xorout", "method", "usedforsecurity", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "crc",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[10];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    Py_buffer data = {NULL, NULL};
    PyObject *name = NULL;
    PyObject *width = NULL;
    PyObject *poly = NULL;
    PyObject *init = NULL;
    PyObject *refin = NULL;
    PyObject *refout = NULL;
    PyObject *xorout = NULL;
    PyObject *method = NULL;
    int usedforsecurity = 0;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        if (PyObject_GetBuffer(args[0], &data, PyBUF_SIMPLE) != 0) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
skip_optional_pos:
    if (!noptargs) {
        goto skip_optional_kwonly;
    }
    if (args[1]) {
        name = args[1];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[2]) {
        width = args[2];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[3]) {
        poly = args[3];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[4]) {
        init = args[4];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[5]) {
        refin = args[5];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[6]) {
        refout = args[6];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[7]) {
        xorout = args[7];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    if (args[8]) {
        if (!PyUnicode_Check(args[8])) {
            _PyArg_BadArgument("crc", "argument 'method'", "str", args[8]);
            goto exit;
        }
        method = args[8];
        if (!--noptargs) {
            goto skip_optional_kwonly;
        }
    }
    usedforsecurity = PyObject_IsTrue(args[9]);
    if (usedforsecurity < 0) {
        goto exit;
    }
skip_optional_kwonly:
    return_value = _crc_crc_impl(module, &data, name, width, poly, init, refin, refout, xorout, method, usedforsecurity);

exit:
    /* Cleanup for data */
    if (data.obj) {
       PyBuffer_Release(&data);
    }

    return return_value;
}

PyDoc_STRVAR(_crc_templates_available__doc__,
"templates_available($module, /)\n"
"--\n"
"\n"
"Return a dict of available templates.\n"
"\n"
"Each template is a tuple (width, poly, init, refin, refout, xorout)\n"
"(see `_crc.crc` for their meaning), mapped by the template name.");

#define _CRC_TEMPLATES_AVAILABLE_METHODDEF    \
    {"templates_available", (PyCFunction)_crc_templates_available, METH_NOARGS, _crc_templates_available__doc__},

static PyObject *
_crc_templates_available_impl(PyObject *module);

static PyObject *
_crc_templates_available(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _crc_templates_available_impl(module);
}
/*[clinic end generated code: output=d0a17e74aa5b6852 input=a9049054013a1b77]*/
